"""
This file will back-test the forum strategy.

In v0.1, we will only test the performance from the trivial method - number of posts increment.
In v0.2, we will add the test of correlation between price and posts.

Note
    1.  We should exclude the IPO period for new stocks since we are not able to buy those stocks.
        Solution -> Skip a fixed period (20 days) after IPO to avoid trading in that period.

    2.  We cannot buy/sell those stocks if they have a 10% daily increase/decrease.
        Solution -> Skip the trading signal if its corresponding price change over 10%.

    3.  We need to check if the stock is tradable (exclude holiday, halted) or not.
        Solution -> The yahoo seems to be fine with this but Bloomberg will use the previous available data
        to replace all the unavailable prices. So we need to exclude those period if BBG is used.

    4.  The total comparable stocks should be greater 200 for crossing signals

    5.  We need to care about the number of posts by using historical average (like 20 days average)
        Reason -> If for stocks A and B,
                                    Stock A     Stock B
                    -> 2018-08-07     1          1000
                    -> 2018-08-08     2          1200
                    -> 2018-08-09     4          1500
        The trivial increment will be:
                                   Stock A     Stock B
                    -> 2018-08-08     2          1.2
                    -> 2018-08-09     2          1.25
        This trivial solution cannot show stock A attracts more attention than B
        Solution -> Instead of ranking the trivial increment matrix, we will further time it by log(ave(posts, days=20))
        which will give us a better sense about the market.
        For this scenario, we cannot say A is better than B so we time a log(ave_post)
        If we suppose ave(A, 20) = 2, ave(B, 20) = 1200, the updated matrix will be:
                                   Stock A     Stock B
                    -> 2018-08-08  2*log(2)    1.2*log(1000)
                    -> 2018-08-09  2*log(2)    1.25*log(1000)
"""
import pandas as pd
import datetime as dt
from progress.bar import Bar
import re
import os
import numpy as np

class SelfSignal:
    """
    Trading signal for backtesting in terms of a single stock which means that
    the signal will be generated by comparing with its historical records
    """
    def __init__(self, ticker):
        self._ticker = ticker

    def create_signal(self):
        pass


class CrossSignal:
    """
    A trading signal matrix will be created by comparing among the universe

    The original posts matrix is
    Sample of stock_post_matrix:
                        Stock A     Stock B     Stock C
        -> 2018-08-07     17          10          10
        -> 2018-08-08     34          30          10
        -> 2018-08-09     30          34          10


    The trivial_change_matrix
    Sample of trivial_change_matrix:
                        Stock A     Stock B     Stock C
        -> 2018-08-08    34/17       30/10       10/10
        -> 2018-08-09    30/34       34/30       10/10

    The trivial_ranking_matrix = rank(cross-stocks forum matrix)
    Sample of ranking_trivial_matrix:
                        Stock A     Stock B     Stock C
        -> 2018-08-08      2           1            3
        -> 2018-08-09      3           1            2

    The dynamic weighting scheme will be
                weight of A at_time_t = stock A's change at_time_t / sum(all stocks changes, at_time_t)
    Sample of dynamic_weights:
                        Stock A     Stock B     Stock C
        -> 2018-08-08     1/3         1/2          1/6
        -> 2018-08-09     0.29        0.38         0.33

    The equal weighting scheme will be
    Sample of equal_weights:
                        Stock A     Stock B     Stock C
        -> 2018-08-08     1/3         1/3          1/3
        -> 2018-08-09     1/3         1/3          1/3

    """

    def __init__(self, start='2010-01-01', end='2019-10-15', number_of_days_for_averaing=20):
        self._start = dt.datetime.strptime(start, '%Y-%m-%d')
        self._end = dt.datetime.strptime(end, '%Y-%m-%d')
        self.date_list = [self._end - dt.timedelta(idx) for idx in range((self._end - self._start).days)]
        self.number_of_days_for_averaing = number_of_days_for_averaing
        self.preprocess()

    def preprocess(self):
        files = os.listdir('data/historical/2019-10-15')
        files = [file for file in files if re.match('[\d]+.csv', file)]
        tickers = [file.split('.')[0] for file in files]
        self.stocks_post_matrix = pd.DataFrame(index=self.date_list)
        with Bar('CrossSignal Preprocessing', max=len(files)) as bar:
            for ticker, file in zip(tickers, files):
                bar.next()
                curr_df = pd.read_csv(f'data/historical/2019-10-15/{file}')
                curr_df['Date'] = curr_df['Time'].apply(lambda x: re.findall('([\d]{4}-[\d]{2}-[\d]{2})', x)[0])
                curr_stock_posts_vec = pd.DataFrame(curr_df.groupby('Date').count().Time.values,
                                                    index=pd.to_datetime(
                                                        curr_df.groupby('Date').count().index, format='%Y-%m-%d'),
                                                    columns=[ticker])
                curr_stock_posts_vec = curr_stock_posts_vec[(curr_stock_posts_vec.index >= self._start) &
                                                            (curr_stock_posts_vec.index <= self._end)]
                self.stocks_post_matrix = pd.concat([self.stocks_post_matrix, curr_stock_posts_vec], axis=1)
        self.stocks_post_matrix = self.stocks_post_matrix.fillna(1)

    @staticmethod
    def add_tradability(df):
        df['tradability'] = df.count(axis=1)
        return df

    @property
    def trivial_change_matrix(self):
        return self.stocks_post_matrix / self.stocks_post_matrix.shift(1)

    @property
    def ranking_trivial_matrix(self):
        return self.trivial_change_matrix.rank(1, method='first', ascending=False)

    @property
    def log_change_matrix(self):
        ave_matrix = self.stocks_post_matrix.rolling(window=self.number_of_days_for_averaing).mean()
        log_matrix = np.log(ave_matrix)
        return self.trivial_change_matrix * log_matrix

    @property
    def log_ranking_matrix(self):
        return self.log_change_matrix.rank(1, method='first', ascending=False)


class Backtest:
    """
    Backtest the trading signal for a single stock
    """
    def __init__(self, signal):
        self._sginal = signal



def run_backtest():
    cs = CrossSignal()
    print(cs.stocks_post_matrix)
    print(cs.trivial_change_matrix)
    print(cs.ranking_trivial_matrix)
    print(cs.add_tradability(cs.log_change_matrix))
    print(cs.add_tradability((cs.log_ranking_matrix)))
    print()


if __name__ == '__main__':
    run_backtest()
