"""
This file will back-test the forum strategy.

In v0.1, we will only test the performance from the trivial method - number of posts increment.
In v0.2, we will add the test of correlation between price and posts.

Note
    1.  We should exclude the IPO period for new stocks since we are not able to buy those stocks.
        Solution -> Skip a fixed period (20 days) after IPO to avoid trading in that period.

    2.  We cannot buy/sell those stocks if they have a 10% daily increase/decrease.
        Solution -> Skip the trading signal if its corresponding price change over 10%.

    3.  We need to check if the stock is tradable (exclude holiday, halted) or not.
        Solution -> The yahoo seems to be fine with this but Bloomberg will use the previous available data
        to replace all the unavailable prices. So we need to exclude those period if BBG is used.

    4.  The total comparable stocks should be greater 200 for crossing signals

    5.  We need to care about the number of posts by using historical average (like 20 days average)
        Reason -> If for stocks A and B,
                                    Stock A     Stock B
                    -> 2018-08-07     1          1000
                    -> 2018-08-08     2          1200
                    -> 2018-08-09     4          1500
        The trivial increment will be:
                                   Stock A     Stock B
                    -> 2018-08-08     2          1.2
                    -> 2018-08-09     2          1.25
        This trivial solution cannot show stock A attracts more attention than B
        Solution -> Instead of ranking the trivial increment matrix, we will further time it by log(ave(posts, days=20))
        which will give us a better sense about the market.
        For this scenario, we cannot say A is better than B so we time a log(ave_post)
        If we suppose ave(A, 20) = 2, ave(B, 20) = 1200, the updated matrix will be:
                                   Stock A     Stock B
                    -> 2018-08-08  2*log(2)    1.2*log(1000)
                    -> 2018-08-09  2*log(2)    1.25*log(1000)
"""
import pandas as pd
import datetime as dt
from progress.bar import Bar
import re
import os
import numpy as np
from snownlp import SnowNLP
from copy import deepcopy

class SelfSignal:
    """
    Trading signal for backtesting in terms of a single stock which means that
    the signal will be generated by comparing with its historical records
    """
    def __init__(self, ticker):
        self._ticker = ticker

    def create_signal(self):
        pass


class CrossSignal:
    """
    A trading signal matrix will be created by comparing among the universe

    The original posts matrix is
    Sample of stock_post_matrix:
                        Stock A     Stock B     Stock C
        -> 2018-08-07     17          10          10
        -> 2018-08-08     34          30          10
        -> 2018-08-09     30          34          10


    The trivial_change_matrix
    Sample of trivial_change_matrix:
                        Stock A     Stock B     Stock C
        -> 2018-08-08    34/17       30/10       10/10
        -> 2018-08-09    30/34       34/30       10/10

    The trivial_ranking_matrix = rank(cross-stocks forum matrix)
    Sample of ranking_trivial_matrix:
                        Stock A     Stock B     Stock C
        -> 2018-08-08      2           1            3
        -> 2018-08-09      3           1            2

    The dynamic weighting scheme will be
                weight of A at_time_t = stock A's change at_time_t / sum(all stocks changes, at_time_t)
    Sample of dynamic_weights:
                        Stock A     Stock B     Stock C
        -> 2018-08-08     1/3         1/2          1/6
        -> 2018-08-09     0.29        0.38         0.33

    The equal weighting scheme will be
    Sample of equal_weights:
                        Stock A     Stock B     Stock C
        -> 2018-08-08     1/3         1/3          1/3
        -> 2018-08-09     1/3         1/3          1/3

    """

    def __init__(self, start='2010-01-01', end='2019-10-15', number_of_days_for_averaing=20):
        self._start = dt.datetime.strptime(start, '%Y-%m-%d')
        self._end = dt.datetime.strptime(end, '%Y-%m-%d')
        self.date_list = [self._end - dt.timedelta(idx) for idx in range((self._end - self._start).days)]
        self.number_of_days_for_averaing = number_of_days_for_averaing
        self.preprocess()

    def preprocess(self):
        files = os.listdir('data/historical/2019-10-15')
        files = [file for file in files if re.match('[\d]+.csv', file)]
        tickers = [file.split('.')[0] for file in files]
        self.stocks_post_matrix = pd.DataFrame(index=self.date_list)
        with Bar('CrossSignal Preprocessing', max=len(files)) as bar:
            for ticker, file in zip(tickers, files):
                bar.next()
                curr_df = pd.read_csv(f'data/historical/2019-10-15/{file}')
                curr_df['Date'] = curr_df['Time'].apply(lambda x: re.findall('([\d]{4}-[\d]{2}-[\d]{2})', x)[0])
                curr_stock_posts_vec = pd.DataFrame(curr_df.groupby('Date').count().Time.values,
                                                    index=pd.to_datetime(
                                                        curr_df.groupby('Date').count().index, format='%Y-%m-%d'),
                                                    columns=[ticker])
                curr_stock_posts_vec = curr_stock_posts_vec[(curr_stock_posts_vec.index >= self._start) &
                                                            (curr_stock_posts_vec.index <= self._end)]
                self.stocks_post_matrix = pd.concat([self.stocks_post_matrix, curr_stock_posts_vec], axis=1)
        self.stocks_post_matrix = self.stocks_post_matrix.fillna(1)

    @property
    def trivial_change_matrix(self):
        return self.stocks_post_matrix / self.stocks_post_matrix.shift(1)

    @property
    def ranking_trivial_matrix(self):
        return self.trivial_change_matrix.rank(1, method='first', ascending=False)

    @property
    def log_change_matrix(self):
        ave_matrix = self.stocks_post_matrix.rolling(window=self.number_of_days_for_averaing).mean()
        log_matrix = np.log(ave_matrix)
        return self.trivial_change_matrix * log_matrix

    @property
    def log_ranking_matrix(self):
        return self.log_change_matrix.rank(1, method='first', ascending=False)


class Backtest:
    """
    Backtest the trading signal for a single stock
    """
    def __init__(self, signal: pd.DataFrame, start='2010-01-01', end='2019-10-15', number_of_skipping_days=20):
        self._sginal = signal
        self._tickers = signal.columns.values.tolist()
        self._start = dt.datetime.strptime(start, '%Y-%m-%d')
        self._end = dt.datetime.strptime(end, '%Y-%m-%d')
        self.date_list = [self._end - dt.timedelta(idx) for idx in range((self._end - self._start).days)]
        self.number_of_skipping_days = 20  # To skip the IPO period
        self.preprocess()

    @staticmethod
    def number_of_available_data_in_row(df):
        df['available_data_in_row'] = df.count(axis=1)
        return df

    def preprocess(self):
        """Build a close prices matrix"""
        self.prices_matrix = pd.DataFrame(index=self.date_list)
        for ticker in self._tickers:
            curr_df = pd.read_csv(f'data/prices/{ticker}.csv', index_col=0, parse_dates=True).Close
            curr_df.name = ticker
            self.prices_matrix = pd.concat([self.prices_matrix, curr_df], axis=1)


    def tradability_matrix(self):
        """
        This function will do three things
            1.  Skip IPO periods
            2.  Skip the day if the stock increase/decrease by 10%
            3.  Skip holiday, halted dates
        :return:
        """
        prices_matrix = deepcopy(self.prices_matrix)
        valid_index = [prices_matrix[col].first_valid_index() for col in prices_matrix.columns]
        for valid_idx, col in zip(valid_index, prices_matrix.columns):
            prices_matrix.loc[valid_index:valid_index + self.number_of_skipping_days, col] = \
                np.repeat(np.nan, self.number_of_skipping_days)





        self.tradability_matrix = pd.DataFrame(np.where(np.isnan(self.prices_matrix), 0, 1),
                                               index=self.prices_matrix.index,
                                               columns=self.prices_matrix.columns)


def sentiment(texts: str):
    text = SnowNLP(texts)
    sents = text.sentences
    for sen in sents:
        s = SnowNLP(sen)
        print(sen, '-', s.sentiments)


def run_backtest():
    start = '2010-01-01'
    end = '2019-10-15'
    cs = CrossSignal(start=start, end=end)
    print(cs.stocks_post_matrix)
    print(cs.trivial_change_matrix)
    print(cs.ranking_trivial_matrix)
    print(cs.log_change_matrix)
    print(cs.log_ranking_matrix)

    bs = Backtest(cs.log_change_matrix, start=start, end=end)

    print()


if __name__ == '__main__':
    # run_backtest()

    text = '快买这个股票，这个股票一定能够大涨，这个不是太好用，' \
           '超级垃圾股票，绝对的优质股票，买这股票就是去送钱，一定亏钱的，'
    sentiment(texts=text)