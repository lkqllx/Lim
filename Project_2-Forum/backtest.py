"""
This file will back-test the forum strategy.

In v0.1, we will only test the performance from the trivial method - number of posts increment.
In v0.2, we will add the test of correlation between price and posts.

Note
    1.  We should exclude the IPO period for new stocks since we are not able to buy those stocks.
        Solution -> Skip a fixed period (20 days) after IPO to avoid trading in that period.

    2.  We cannot buy/sell those stocks if they have a 10% daily increase/decrease.
        Solution -> Skip the trading signal if its corresponding price change over 10%.

    3.  We need to check if the stock is tradable (exclude holiday, halted) or not.
        Solution -> The yahoo seems to be fine with this but Bloomberg will use the previous available data
        to replace all the unavailable prices. So we need to exclude those period if BBG is used.

    4.  The total comparable should be greater 200 stocks for crossing signals
"""
import pandas_datareader as web
import pandas as pd
import datetime as dt
from progress.bar import Bar
import re
import os


class SelfSignal:
    """
    Trading signal for backtesting in terms of a single stock which means that
    the signal will be generated by comparing with its historical records
    """
    def __init__(self, ticker):
        self._ticker = ticker

    def create_signal(self):
        pass


class CrossSignal:
    """
    A trading signal matrix will be created by comparing among the universe

    The cross_stocks_forum_matrix
    Sample:
                        Stock A     Stock B     Stock C
        -> 2018-08-08    34/17       30/10       10/10
        -> 2018-08-09    30/10       34/17       10/10

    The ranking_matrix = rank(cross-stocks forum matrix)
    Sample:
                        Stock A     Stock B     Stock C
        -> 2018-08-08      2           1            3
        -> 2018-08-09      1           2            3

    The dynamic weighting scheme will be
                weights = stock's daily changes / sum(all stocks changes, at_day_n)
    Sample:
                        Stock A     Stock B     Stock C
        -> 2018-08-08     1/3         1/2          1/6
        -> 2018-08-09     1/2         1/3          1/6

    The equal weighting scheme will be
    Sample:
                        Stock A     Stock B     Stock C
        -> 2018-08-08     1/3         1/3          1/3
        -> 2018-08-09     1/3         1/3          1/3
    """

    def __init__(self, start='2010-01-01', end='2019-10-15'):
        self._start = dt.datetime.strptime(start, '%Y-%m-%d')
        self._end = dt.datetime.strptime(end, '%Y-%m-%d')
        self.date_list = [self._end - dt.timedelta(idx) for idx in range((self._end - self._start).days)]
        self.preprocess()

    def preprocess(self):
        files = os.listdir('data/historical/2019-10-15')
        files = [file for file in files if re.match('[\d]+.csv', file)]
        tickers = [file.split('.')[0] for file in files]
        self.stocks_post_matrix = pd.DataFrame(index=self.date_list)
        with Bar('CrossSignal Preprocessing', max=len(files)) as bar:
            for ticker, file in zip(tickers, files):
                bar.next()
                curr_df = pd.read_csv(f'data/historical/2019-10-15/{file}')
                curr_df['Date'] = curr_df['Time'].apply(lambda x: re.findall('([\d]{4}-[\d]{2}-[\d]{2})', x)[0])
                curr_stock_posts_vec = pd.DataFrame(curr_df.groupby('Date').count().Time.values,
                                                    index=pd.to_datetime(
                                                        curr_df.groupby('Date').count().index, format='%Y-%m-%d'),
                                                    columns=[ticker])

                self.stocks_post_matrix = pd.concat([self.stocks_post_matrix, curr_stock_posts_vec], axis=1)

    @staticmethod
    @property
    def cross_stocks_forum_matrix():
        pass




class Backtest:
    """
    Backtest the trading signal for a single stock
    """
    pass


def run():
    cs = CrossSignal()

    pass


if __name__ == '__main__':
    run()
